<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="面试,interview," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="本文总结了平常面试可能会遇到的面试题，会不断完善，请读者注意发布时间，文章不保证失效性，在版本更新后可能会有所差异">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="https://zeozhang.github.io/Other/Interview/index.html">
<meta property="og:site_name" content="CoderFaith">
<meta property="og:description" content="本文总结了平常面试可能会遇到的面试题，会不断完善，请读者注意发布时间，文章不保证失效性，在版本更新后可能会有所差异">
<meta property="og:image" content="https://zeozhang.github.io/img/activityshengmingzhouqi.gif">
<meta property="og:updated_time" content="2017-03-23T09:37:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试题">
<meta name="twitter:description" content="本文总结了平常面试可能会遇到的面试题，会不断完善，请读者注意发布时间，文章不保证失效性，在版本更新后可能会有所差异">
<meta name="twitter:image" content="https://zeozhang.github.io/img/activityshengmingzhouqi.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zeozhang.github.io/Other/Interview/"/>





  <title> 面试题 | CoderFaith </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">CoderFaith</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Your should have faith.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://zeozhang.github.io/Other/Interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zeo Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CoderFaith">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                面试题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-21T12:03:50+08:00">
                2017-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Other/" itemprop="url" rel="index">
                    <span itemprop="name">Other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  本文总结了平常面试可能会遇到的面试题，会不断完善，请读者注意发布时间，文章不保证失效性，在版本更新后可能会有所差异
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<ol>
<li><p><a href="#1">Activity的生命周期(Fragment的生命周期)</a></p>
</li>
<li><p><a href="#2">数据储存方式</a></p>
</li>
<li><p><a href="#3">Handler机制和分析</a></p>
</li>
<li><p><a href="#4">Asynctask优缺点(分析)</a></p>
</li>
<li><p><a href="#5">对比以上两种优缺点</a></p>
</li>
<li><p><a href="#6">Service的概念</a></p>
</li>
<li><p><a href="#7">Service保活</a></p>
</li>
<li><p><a href="#8">自定义View</a></p>
</li>
<li><p><a href="#9">进程</a></p>
</li>
<li><p><a href="#10">Context</a></p>
</li>
<li><p><a href="#11">内存泄露和防止内存泄漏</a></p>
</li>
<li><p><a href="#12">数据解析</a></p>
</li>
<li><p><a href="#13">事件分发机制</a></p>
</li>
<li><p><a href="#14">webview使用</a></p>
</li>
<li><p><a href="#15">数据传输的加密</a></p>
</li>
<li><p><a href="#16">surfaceview</a></p>
</li>
<li><p><a href="#17">ANR的概念和避免</a></p>
</li>
<li><p><a href="#18">FC</a></p>
</li>
<li><p><a href="#19">性能优化 </a></p>
</li>
<li><p><a href="#20">动态加载(插件化)</a></p>
</li>
<li><p><a href="#21">热修复 </a></p>
</li>
<li><p><a href="#22">异常捕获和处理</a></p>
</li>
<li><p><a href="#23">AIDL的方式(多线程间通信和多进程之间通信有什么不同)</a></p>
</li>
<li><p><a href="#24">安卓系统架构</a></p>
</li>
<li><p><a href="#25">Android程序运行时权限与文件系统权限</a></p>
</li>
<li><p><a href="#26">适配(屏幕和系统)</a></p>
</li>
<li><p><a href="#27">动画*</a></p>
</li>
<li><p><a href="#28">Other</a></p>
</li>
</ol>
<hr>
<h1 id="Activity的生命周期-Fragment的生命周期"><a href="#Activity的生命周期-Fragment的生命周期" class="headerlink" title="Activity的生命周期(Fragment的生命周期)"></a><a id="1" name="1">Activity的生命周期(Fragment的生命周期)</a></h1><h2 id="什么是Activity的-“生命周期”"><a href="#什么是Activity的-“生命周期”" class="headerlink" title="什么是Activity的 “生命周期”"></a>什么是Activity的 “生命周期”</h2><p>运行中的应用程序分为五大类，分别是：</p>
<ul>
<li><p>前景模式：foreground process</p>
</li>
<li><p>可见模式：visible process</p>
</li>
<li><p>背景模式：background process</p>
</li>
<li><p>空白模式：empty process</p>
</li>
<li><p>服务模式：service process</p>
</li>
</ul>
<p>除了最后一个，貌似service process是Service的事情了。其他都与Activity相关。</p>
<p>Android系统会判断应用程序Activity是属于哪一个类，给予不同的Activity生命周期。 </p>
<p><img src="/img/activityshengmingzhouqi.gif" alt="Activity生命周期"></p>
<blockquote>
<p>activity包含七个生命周期的方法：</p>
<p>（1）onCreate()：创建时被调用</p>
<p>（2）onStart():可见时被调用</p>
<p>（3）onRestart():重新可见时被调用，接着会调用onStart()</p>
<p>（4）onResumed():activity获得焦点，可进行输入时被调用</p>
<p>（5）onPaused():失去焦点但可见时被调用（在其他应用需要内存时，可能会被kills）</p>
<p>（6）onStopped():完全不可见时被调用，会被系统kills</p>
<p>（7）onDestroyed():被销毁时被调用，会被系统kills</p>
</blockquote>
<h2 id="被调用的情况"><a href="#被调用的情况" class="headerlink" title="被调用的情况"></a>被调用的情况</h2><p>1.启动Activity：系统会先调用onCreate方法，然后调用onStart方法，最后调用onResume，Activity进入运行状态。</p>
<p>2.当前Activity被其他Activity覆盖其上或被锁屏：系统会调用onPause方法，暂停当前Activity的执行。</p>
<p>3.当前Activity由被覆盖状态回到前台或解锁屏：系统会调用onResume方法，再次进入运行状态。</p>
<p>4.当前Activity转到新的Activity界面或按Home键回到主屏，自身退居后台：系统会先调用onPause方法，然后调用onStop方法，进入停滞状态。</p>
<p>5.用户后退回到此Activity：系统会先调用onRestart方法，然后调用onStart方法，最后调用onResume方法，再次进入运行状态。</p>
<p>6.当前Activity处于被覆盖状态或者后台不可见状态，即第2步和第4步，系统内存不足，杀死当前Activity，而后用户退回当前Activity：再次调用onCreate方法、onStart方法、onResume方法，进入运行状态。</p>
<p>7.用户退出当前Activity：系统先调用onPause方法，然后调用onStop方法，最后调用onDestory方法，结束当前Activity。<br>但是知道这些还不够，我们必须亲自试验一下才能深刻体会，融会贯通。</p>
<p>8*.在Activity被其他非全屏Activity（Theme属性使用了dialog主题）覆盖时，会调用onPause</p>
<h2 id="保存Activity状态"><a href="#保存Activity状态" class="headerlink" title="保存Activity状态"></a>保存Activity状态</h2><p>当我们的activity开始Stop，系统会调用 onSaveInstanceState()，Activity可以用键值对的集合来保存状态信息。这个方法会默认保存Activity视图的状态信息，如在 EditText 组件中的文本或 ListView的滑动位置。</p>
<p>为了给Activity保存额外的状态信息，你必须实现onSaveInstanceState()并增加key-value pairs到 Bundle 对象中。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String STATE_SCORE = <span class="string">"playerScore"</span>;</div><div class="line"><span class="keyword">static</span> finalString STATE_LEVEL = <span class="string">"playerLevel"</span>;</div><div class="line">...</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle </span></span></div><div class="line">savedInstanceState) &#123;</div><div class="line">    <span class="comment">// Save the user's current game state</span></div><div class="line">   savedInstanceState.putInt(STATE_SCORE, mCurrentScore);</div><div class="line">   savedInstanceState.putInt(STATE_LEVEL, mCurrentLevel);</div><div class="line">    <span class="comment">// Always call thesuperclass so it can save the view hierarchy state</span></div><div class="line">    <span class="keyword">super</span>.onSaveInstanceState(savedInstanceState);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Caution: 必须要调用 onSaveInstanceState()方法的父类实现，这样默认的父类实现才能保存视图状态的信息。</p>
</blockquote>
<h2 id="更多请参考"><a href="#更多请参考" class="headerlink" title="更多请参考"></a>更多请参考</h2><blockquote>
<p><a href="http://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="external">http://developer.android.com/reference/android/app/Activity.html</a></p>
<p><a href="http://developer.android.com/training/basics/activity-lifecycle/starting.html" target="_blank" rel="external">http://developer.android.com/training/basics/activity-lifecycle/starting.html</a></p>
<p><a href="http://developer.android.com/training/basics/activity-lifecycle/pausing.html" target="_blank" rel="external">http://developer.android.com/training/basics/activity-lifecycle/pausing.html</a></p>
<p><a href="http://developer.android.com/training/basics/activity-lifecycle/stopping.html" target="_blank" rel="external">http://developer.android.com/training/basics/activity-lifecycle/stopping.html</a></p>
<p><a href="http://developer.android.com/training/basics/activity-lifecycle/recreating.html" target="_blank" rel="external">http://developer.android.com/training/basics/activity-lifecycle/recreating.html</a></p>
<p><a href="http://developer.android.com/guide/components/activities.html" target="_blank" rel="external">http://developer.android.com/guide/components/activities.html</a></p>
<p><a href="http://www.apkbus.com/android-18204-1-1.html" target="_blank" rel="external">一个帖子学会Android四大组件</a></p>
<p><a href="http://www.apkbus.com/blog-99192-39550.html" target="_blank" rel="external">两分钟明白Activity生命周期</a></p>
</blockquote>
<hr>
<h1 id="数据储存方式"><a href="#数据储存方式" class="headerlink" title="数据储存方式"></a><a id="2" name="2">数据储存方式</a></h1><p>SQLite：SQLite是一个轻量级的数据库，支持基本的SQL语法，是常被采用的一种数据存储方式。 Android为此数据库提供了一个名为SQLiteDatabase的类，封装了一些操作数据库的api</p>
<p>SharedPreference： 以键值对的形势储存。其本质就是一个xml文件，常用于存储较简单的参数设置。</p>
<p>File： 即常说的文件（I/O）存储方法，常用语存储大数量的数据，但是缺点是更新数据将是一件困难的事情。</p>
<p>ContentProvider: Android系统中能实现所有应用程序共享的一种数据存储方式，由于数据通常在各应用间的是互相私密的，所以此存储方式较少使用，但是其又是必不可少的一种存储方式。例如音频，视频，图片和通讯录，一般都可以采用此种方式进行存储。每个Content Provider都会对外提供一个公共的URI（包装成Uri对象），如果应用程序有数据需要共享时，就需要使用Content Provider为这些数据定义一个URI，然后其他的应用程序就通过Content Provider传入这个URI来对数据进行操作。</p>
<hr>
<h1 id="Handler机制和分析"><a href="#Handler机制和分析" class="headerlink" title="Handler机制和分析"></a><a name="3" id="3">Handler机制和分析</a></h1><p>andriod提供了Handler 和 Looper 来满足线程间的通信。Handler先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(MessageExchange)。</p>
<p>Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的MessageQueue(消息队列)。</p>
<p>Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到MessageQueue里;或者接收Looper从Message Queue取出)所送来的消息。</p>
<p>Message Queue(消息队列):用来存放线程放入的消息。<br>线程：UIthread 通常就是main thread，而Android启动程序时会替它建立一个MessageQueue。</p>
<hr>
<h1 id="Asynctask优缺点-分析"><a href="#Asynctask优缺点-分析" class="headerlink" title="Asynctask优缺点(分析)"></a><a name="4" id="4">Asynctask优缺点(分析)</a></h1><p>多为分析AsyncTask的缺点和问题，其他在 <a href="#5">下一点</a> 中分析</p>
<h2 id="关于Asynctask"><a href="#关于Asynctask" class="headerlink" title="关于Asynctask"></a>关于Asynctask</h2><p>asynctask对应的线程池ThreadPoolExecutor都是进程范围内共享的，都是static的，所以是asynctask控制着进程范围内所有的子类实例。由于这个限制的存在，当使用默认线程池时，如果线程数超过线程池的最大容量，线程池就会爆掉(3.0后默认串行执行，不会出现这个问题)。针对这种情况，可以尝试自定义线程池，配合asynctask使用。</p>
<blockquote>
<p>核心线程池中最多有CPU_COUNT+1个，最多有CPU_COUNT*2+1个，线程等待队列的最大等待数为128，但是可以自定义线程池。线程池是由AsyncTask来管理的，线程池允许tasks并行运行，需要注意的是并发情况下数据的一致性问题，新数据可能会被老数据覆盖掉，类似volatile变量。所以希望tasks能够串行运行的话，使用SERIAL_EXECUTOR。</p>
</blockquote>
<p>AsyncTask在SDK 1.6之前，异步任务是放在一个独立的线程中的。也就是说所有的异步操作需要一个一个进行。1.6之后可以进行五个。如果AsyncTask实例超过5个则需要等待。2.3版本之前这个问题是无法解决了。<br>2.3之后可以自定义线程池，但是必须放弃AsyncTask，自己创建线程池来管理Thread。</p>
<p>从Android3.0开始对AsyncTask的API作出了一些调整：每次只启动一个线程执行一个任务，完成之后再执行第二个任务，也就是相当于只有一个后台线程在执行所提交的任务。</p>
<h2 id="AsyncTask的使用"><a href="#AsyncTask的使用" class="headerlink" title="AsyncTask的使用"></a>AsyncTask的使用</h2><h3 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1.生命周期"></a>1.生命周期</h3><p>很多开发者会认为一个在Activity中创建的AsyncTask会随着Activity的销毁而销毁。然而事实并非如此。AsyncTask会一直执行，直到doInBackground()方法执行完毕。然后，如果cancel(boolean)被调用,那么onCancelled(Result result)方法会被执行；否则，执行onPostExecute(Result result)方法。如果我们的Activity销毁之前，没有取消AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。因为它想要处理的view已经不在了。所以，我们总是必须确保在销毁活动之前取消任务。总之，我们使用AsyncTask需要确保AsyncTask正确的取消。</p>
<h3 id="2-内存泄漏"><a href="#2-内存泄漏" class="headerlink" title="2.内存泄漏"></a>2.内存泄漏</h3><p>如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄漏。</p>
<h3 id="3-结果丢失"><a href="#3-结果丢失" class="headerlink" title="3.结果丢失"></a>3.结果丢失</h3><p>屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。</p>
<h3 id="4-并行还是串行"><a href="#4-并行还是串行" class="headerlink" title="4.并行还是串行"></a>4.并行还是串行</h3><p>在Android1.6之前的版本，AsyncTask是串行的，在1.6至2.3的版本，改成了并行的。在2.3之后的版本又做了 修改，可以支持并行和串行，当想要串行执行时，直接执行execute()方法，如果需要执行executeOnExecutor(Executor)。</p>
<hr>
<h1 id="对比以上两种优缺点-Handler和AsyncTask"><a href="#对比以上两种优缺点-Handler和AsyncTask" class="headerlink" title="对比以上两种优缺点(Handler和AsyncTask)"></a><a name="5" id="5">对比以上两种优缺点(Handler和AsyncTask)</a></h1><table>
<thead>
<tr>
<th>–</th>
<th>Handler</th>
<th>AsyncTask</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>简单,快捷过程可控制</td>
<td>结构清晰，功能定义明确；对于多个后台任务时，简单，清晰</td>
</tr>
<tr>
<td>缺点</td>
<td>在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来.</td>
<td>在单个后台异步处理时，显得代码过多，结构过于复杂（相对性）</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="Service的概念"><a href="#Service的概念" class="headerlink" title="Service的概念"></a><a name="6" id="6">Service的概念</a></h1><blockquote>
<p><em>Context相关</em></p>
<p>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper.</p>
<p>每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象<br>getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法，getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。<br>创建Toast和对话框不可以用Application 的context，只能用Activity的context。<br>Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application</p>
</blockquote>
<h2 id="service的分类"><a href="#service的分类" class="headerlink" title="service的分类"></a>service的分类</h2><p>service按照使用可以分为：</p>
<p>1、startService 启动的服务：主要用于启动一个服务执行后台任务，不进行通信。停止服务只能使用stopService；</p>
<p>2、bindService 启动的服务：该方法启动的服务可以进行通信。停止服务使用unbindService或者结束Activity；</p>
<p>3、startService 同时也 bindService 启动的服务：停止服务应同时使用stepService与unbindService。</p>
<blockquote>
<p>onBind方法更多的是结合AIDL来使用，这样一个应用可以通过绑定服务获得的IBinder来拿到后台的接口，进而调用AIDL中定义的方法，进行数据交换等。</p>
</blockquote>
<p>参考：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/lwbqqyumidi/p/4181185.html" target="_blank" rel="external">http://www.cnblogs.com/lwbqqyumidi/p/4181185.html</a></p>
</blockquote>
<hr>
<h1 id="Service保活"><a href="#Service保活" class="headerlink" title="Service保活"></a><a name="7" id="7">Service保活</a></h1><h2 id="1-提供进程优先级，降低进程被杀死的概率"><a href="#1-提供进程优先级，降低进程被杀死的概率" class="headerlink" title="1. 提供进程优先级，降低进程被杀死的概率"></a>1. 提供进程优先级，降低进程被杀死的概率</h2><p>方法一：监控手机锁屏解锁事件，在屏幕锁屏时启动1个像素的 Activity，在用户解锁时将 Activity 销毁掉。</p>
<p>方法二：启动前台service。</p>
<p>方法三：提升service优先级：</p>
<p>在AndroidManifest.xml文件中对于intent-filter可以通过android:priority = “1000”这个属性设置最高优先级，<br>1000是最高值，如果数字越小则优先级越低，同时适用于广播。</p>
<h2 id="2-在进程被杀死后，进行拉活"><a href="#2-在进程被杀死后，进行拉活" class="headerlink" title="2. 在进程被杀死后，进行拉活"></a>2. 在进程被杀死后，进行拉活</h2><p>方法一：注册高频率广播接收器，唤起进程。如网络变化，解锁屏幕，开机等</p>
<p>方法二：双进程相互唤起。</p>
<p>方法三：依靠系统唤起。</p>
<p>方法四：onDestroy方法里重启service：service +broadcast 方式，就是当service走ondestory的时候，发送一个自定义的广播，当收到广播的时候，重新启动service；</p>
<h2 id="3-依靠第三方"><a href="#3-依靠第三方" class="headerlink" title="3. 依靠第三方"></a>3. 依靠第三方</h2><p>根据终端不同，在小米手机（包括 MIUI）接入小米推送、华为手机接入华为推送；其他手机可以考虑接入腾讯信鸽或极光推送与小米推送做 A/B Test。</p>
<blockquote>
<p>另外腾讯bugly有一篇特别详细的：<a href="http://mp.weixin.qq.com/s?__biz=MzA3NTYzODYzMg==&amp;mid=2653577617&amp;idx=1&amp;sn=623256a2ff94641036a6c9eea17baab8&amp;scene=0#wechat_redirect" target="_blank" rel="external">进程保活大全</a></p>
</blockquote>
<p>其实说到底，在国产UI的淫威下，你能怎么办呢？还不如弹窗弹个萌妹子，友好提示用户，“欧巴，把我们加到白名单吧”</p>
<hr>
<h1 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a><a name="8" id="8">自定义View</a></h1><p>自定义View的相关方法</p>
<p>1.自定义属性</p>
<p>2.onLayout(Viewgroup)</p>
<p>3.onMesure</p>
<p>4.onDraw</p>
<p>5.交互:</p>
<p>onIntercepterTouchEvent()</p>
<p>onTouchEvent()</p>
<p>参考：</p>
<blockquote>
<p><a href="#13">事件分发机制</a></p>
</blockquote>
<hr>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a><a name="9" id="9">进程</a></h1><h2 id="进程的详解"><a href="#进程的详解" class="headerlink" title="进程的详解"></a>进程的详解</h2><ol>
<li>默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果需要控制某个组件所属的进程，则可在清单文件中执行此操作。各类组件元素的清单文件条目 —<activity>、<service>、<receiver> 、<provider>— 均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。</provider></receiver></service></activity></li>
<li>此外，<application> 元素还支持 android:process 属性，以设置适用于所有组件的默认值。</application></li>
<li>如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。</li>
</ol>
<p><em>决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 的进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。</em></p>
<h2 id="进程终止的规则"><a href="#进程终止的规则" class="headerlink" title="进程终止的规则"></a>进程终止的规则</h2><blockquote>
<p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。 </p>
</blockquote>
<ul>
<li>前台进程：即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的</li>
<li>可见进程：可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互</li>
<li>服务进程：其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等；当系统要空间运行前两者进程时才会被终止</li>
<li>后台进程：其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这样的进程系统一旦没了有内存就首先被杀死</li>
<li>空进程：不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的</li>
</ul>
<hr>
<h1 id="Context相关"><a href="#Context相关" class="headerlink" title="Context相关"></a><a name="10" id="10">Context相关</a></h1><p>Activity和Service以及Application的Context是不一样的,Activity继承自ContextThemeWraper.其他的继承自ContextWrapper.</p>
<p>每一个Activity和Service以及Application的Context都是一个新的ContextImpl对象<br>getApplication()用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法，getApplicationContext()比getApplication()方法的作用域会更广一些，任何一个Context的实例，只要调用getApplicationContext()方法都可以拿到我们的Application对象。<br>创建Toast和对话框不可以用Application 的context，只能用Activity的context。<br>Context的数量等于Activity的个数 + Service的个数 + 1，这个1为Application</p>
<h1 id="内存泄露和防止内存泄漏"><a href="#内存泄露和防止内存泄漏" class="headerlink" title="内存泄露和防止内存泄漏"></a><a name="11" id="11">内存泄露和防止内存泄漏</a></h1><h2 id="引起内存泄漏的情况"><a href="#引起内存泄漏的情况" class="headerlink" title="引起内存泄漏的情况"></a>引起内存泄漏的情况</h2><ul>
<li>对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。</li>
<li>静态内部类持有外部成员变量（或context）:可以使用弱引用或使用ApplicationContext。</li>
<li>内部类持有外部类引用,异步任务中，持有外部成员变量。<br>集合中没用的对象没有及时remove。</li>
<li>不用的对象及时释放，如使用完Bitmap后掉用recycle（），再赋null。</li>
<li>handler引起的内存泄漏，MessageQueue里的消息如果在activity销毁时没有处理完，就会引起内存的泄漏，可以使用弱引用解决。</li>
<li>设置过的监听不用时，及时移除。如在Destroy时及时remove。尤其以addListener开头的，在Destroy中都需要remove。</li>
<li>activity泄漏可以使用LeakCanary。</li>
</ul>
<h2 id="解决内存泄漏的简单方法"><a href="#解决内存泄漏的简单方法" class="headerlink" title="解决内存泄漏的简单方法"></a>解决内存泄漏的简单方法</h2><ul>
<li>在内存引用上做些处理，常用的有软引用、弱引用</li>
<li>在内存中加载图片时直接在内存中作处理，如：边界压缩</li>
<li>动态回收内存</li>
<li>优化Dalvik虚拟机的堆内存分配</li>
<li>自定义堆内存大小</li>
</ul>
<p>参考:</p>
<blockquote>
<p><a href="http://mzh3344258.blog.51cto.com/1823534/804237" target="_blank" rel="external">http://mzh3344258.blog.51cto.com/1823534/804237</a></p>
</blockquote>
<hr>
<h1 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a><a name="12" id="12">数据解析</a></h1><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><blockquote>
<ul>
<li>JSON的全程是JavaScript Object Notation，也就是JavaScript 对象表示法</li>
<li>JSON是存储和交换文本信息的语法，类似XML，但是比XML更小、更快，更易解析</li>
<li>JSON是轻量级的文本数据交换格式，独立于语言，具有自我描述性，更易理解</li>
<li>键值对方式，例如{“name”:”zhangsan” , “age”:25}</li>
<li>使用谷歌的GSON包进行解析</li>
<li>值得注意的是实体类中变量名称必须和json中的值名相同。</li>
</ul>
</blockquote>
<p>解析实例：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Gson gson</span> = new Gson();</div><div class="line"><span class="attribute">Student student</span> = gson.fromJson(json1, Student.class);</div></pre></td></tr></table></figure>
<p>我们可以解析成int数组，也可以解析成Integer的List。<br>解析成数组：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Gson gson = <span class="keyword">new</span> Gson();</div><div class="line"><span class="built_in">int</span>[] ages = gson.fromJson(json2, <span class="built_in">int</span>[].<span class="keyword">class</span>);</div><div class="line">解析成<span class="built_in">List</span>：</div><div class="line"></div><div class="line">Gson gson = <span class="keyword">new</span> Gson();</div><div class="line"><span class="built_in">List</span>&lt;Integer&gt; ages = gson.fromJson(json2, <span class="keyword">new</span> TypeToken&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt;()&#123;&#125;.getType);</div></pre></td></tr></table></figure>
<p>同样可以解析成List或者数组，我们就直接解析成List.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Gson gson = <span class="keyword">new</span> Gson();</div><div class="line"><span class="built_in">List</span>&lt;Student&gt; students = gson.fromJson(json3, <span class="keyword">new</span> TypeToke&lt;<span class="built_in">List</span>&lt;Student&gt;&gt;()&#123;&#125;.getType);</div></pre></td></tr></table></figure>
<h2 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h2><p>只对比一下优缺点，简单了解</p>
<ul>
<li>DOM解析</li>
</ul>
<blockquote>
<p>优点:</p>
<p>1.XML树在内存中完整存储,因此可以直接修改其数据和结构.</p>
<p>2.可以通过该解析器随时访问XML树中的任何一个节点.</p>
<p>3.DOM解析器的API在使用上也相对比较简单.<br>缺点:如果XML文档体积比较大时,将文档读入内存是非常消耗系统资源的.</p>
<p>使用场景:DOM 是用与平台和语言无关的方式表示 XML 文档的官方 W3C 标准.DOM 是以层次结构组织的节点的集合.这个层次结构允许开发人员在树中寻找特定信息.分析该结构通常需要加载整个文档和构造层次结构,然后才能进行任何工作.DOM是基于对象层次结构的.</p>
</blockquote>
<ul>
<li>SAX解析</li>
</ul>
<blockquote>
<p>优点:</p>
<p>SAX 对内存的要求比较低,因为它让开发人员自己来决定所要处理的标签.特别是当开发人员只需要处理文档中所包含的部分数据时,SAX 这种扩展能力得到了更好的体现.</p>
<p>缺点:</p>
<p>用SAX方式进行XML解析时,需要顺序执行,所以很难访问到同一文档中的不同数据.此外,在基于该方式的解析编码过程也相对复杂.</p>
<p>使用场景:</p>
<p>对于含有数据量十分巨大,而又不用对文档的所有数据进行遍历或者分析的时候,使用该方法十分有效.该方法不用将整个文档读入内存,而只需读取到程序所需的文档标签处即可.</p>
</blockquote>
<ul>
<li>Xmlpull解析</li>
</ul>
<blockquote>
<p>android SDK提供了xmlpull api,xmlpull和sax类似,是基于流（stream）操作文件,然后根据节点事件回调开发者编写的处理程序.因为是基于流的处理,因此xmlpull和sax都比较节约内存资源,不会象dom那样要把所有节点以对橡树的形式展现在内存中.xmlpull比sax更简明,而且不需要扫描完整个流.</p>
</blockquote>
<hr>
<h1 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a><a name="13" id="13">事件分发机制</a></h1><p>当手指触摸到屏幕时，系统就会调用相应View的onTouchEvent，并传入一系列的action。</p>
<p>dispatchTouchEvent的执行顺序为：</p>
<p>首先触发ACTIVITY的dispatchTouchEvent,然后触发ACTIVITY的onInterceptTouchEvent.<br>然后触发LAYOUT的dispatchTouchEvent，然后触发LAYOUT的onInterceptTouchEvent<br>这就解释了重写ViewGroup时必须调用super.dispatchTouchEvent();</p>
<p>(1)dispatchTouchEvent:</p>
<p>此方法一般用于初步处理事件，因为动作是由此分发，所以通常会调用super.dispatchTouchEvent。这样就会继续调用onInterceptTouchEvent，再由onInterceptTouchEvent决定事件流向。</p>
<p>(2)onInterceptTouchEvent:</p>
<p>若返回值为true事件会传递到自己的onTouchEvent();若返回值为false传递到下一个View的dispatchTouchEvent();</p>
<p>(3)onTouchEvent():</p>
<p>若返回值为true，事件由自己消耗，后续动作让其处理；若返回值为false，自己不消耗事件了，向上返回让其他的父View的onTouchEvent接受处理</p>
<p>三大方法关系的伪代码：如果当前View拦截事件，就交给自己的onTouchEvent去处理，否则就丢给子View继续走相同的流程。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
            <a href="/tags/interview/" rel="tag"># interview</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/uncategorized/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/Android/Android规范/" rel="prev" title="Android编程规范">
                Android编程规范 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Zeo Zhang" />
          <p class="site-author-name" itemprop="name">Zeo Zhang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">Kategorien</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Activity的生命周期-Fragment的生命周期"><span class="nav-number">1.</span> <span class="nav-text">Activity的生命周期(Fragment的生命周期)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是Activity的-“生命周期”"><span class="nav-number">1.1.</span> <span class="nav-text">什么是Activity的 “生命周期”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#被调用的情况"><span class="nav-number">1.2.</span> <span class="nav-text">被调用的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保存Activity状态"><span class="nav-number">1.3.</span> <span class="nav-text">保存Activity状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多请参考"><span class="nav-number">1.4.</span> <span class="nav-text">更多请参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据储存方式"><span class="nav-number">2.</span> <span class="nav-text">数据储存方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Handler机制和分析"><span class="nav-number">3.</span> <span class="nav-text">Handler机制和分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Asynctask优缺点-分析"><span class="nav-number">4.</span> <span class="nav-text">Asynctask优缺点(分析)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于Asynctask"><span class="nav-number">4.1.</span> <span class="nav-text">关于Asynctask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AsyncTask的使用"><span class="nav-number">4.2.</span> <span class="nav-text">AsyncTask的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-生命周期"><span class="nav-number">4.2.1.</span> <span class="nav-text">1.生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-内存泄漏"><span class="nav-number">4.2.2.</span> <span class="nav-text">2.内存泄漏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-结果丢失"><span class="nav-number">4.2.3.</span> <span class="nav-text">3.结果丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-并行还是串行"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.并行还是串行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对比以上两种优缺点-Handler和AsyncTask"><span class="nav-number">5.</span> <span class="nav-text">对比以上两种优缺点(Handler和AsyncTask)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Service的概念"><span class="nav-number">6.</span> <span class="nav-text">Service的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#service的分类"><span class="nav-number">6.1.</span> <span class="nav-text">service的分类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Service保活"><span class="nav-number">7.</span> <span class="nav-text">Service保活</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-提供进程优先级，降低进程被杀死的概率"><span class="nav-number">7.1.</span> <span class="nav-text">1. 提供进程优先级，降低进程被杀死的概率</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-在进程被杀死后，进行拉活"><span class="nav-number">7.2.</span> <span class="nav-text">2. 在进程被杀死后，进行拉活</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-依靠第三方"><span class="nav-number">7.3.</span> <span class="nav-text">3. 依靠第三方</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自定义View"><span class="nav-number">8.</span> <span class="nav-text">自定义View</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#进程"><span class="nav-number">9.</span> <span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的详解"><span class="nav-number">9.1.</span> <span class="nav-text">进程的详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程终止的规则"><span class="nav-number">9.2.</span> <span class="nav-text">进程终止的规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Context相关"><span class="nav-number">10.</span> <span class="nav-text">Context相关</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存泄露和防止内存泄漏"><span class="nav-number">11.</span> <span class="nav-text">内存泄露和防止内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引起内存泄漏的情况"><span class="nav-number">11.1.</span> <span class="nav-text">引起内存泄漏的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决内存泄漏的简单方法"><span class="nav-number">11.2.</span> <span class="nav-text">解决内存泄漏的简单方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据解析"><span class="nav-number">12.</span> <span class="nav-text">数据解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON"><span class="nav-number">12.1.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xml解析"><span class="nav-number">12.2.</span> <span class="nav-text">xml解析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#事件分发机制"><span class="nav-number">13.</span> <span class="nav-text">事件分发机制</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zeo Zhang</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>
